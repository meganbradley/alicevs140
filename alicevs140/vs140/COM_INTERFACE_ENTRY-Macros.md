---
title: "COM_INTERFACE_ENTRY Macros"
ms.custom: na
ms.date: 09/19/2016
ms.devlang: 
  - C++
ms.prod: visual-studio-dev14
ms.reviewer: na
ms.suite: na
ms.technology: 
  - devlang-cpp
ms.tgt_pltfrm: na
ms.topic: reference
ms.assetid: 19dcb768-2e1f-4b8d-a618-453a01a4bd00
caps.latest.revision: 14
translation.priority.ht: 
  - de-de
  - ja-jp
---
# COM_INTERFACE_ENTRY Macros
These macros enter an object's interfaces into its COM map so that they can be accessed by `QueryInterface`. The order of entries in the COM map is the order interfaces will be checked for a matching **IID** during `QueryInterface`.  
  
 Each object that wants to expose its interfaces via `QueryInterface` must have its own COM map. The COM map starts with the macro [BEGIN_COM_MAP](../vs140/BEGIN_COM_MAP.md). Interface entries are added with one or more of the **COM_INTERFACE_ENTRY** macros, and the map is completed with the [END_COM_MAP](../vs140/END_COM_MAP.md) macro. For example:  
  
 [!CODE [NVC_ATL_Windowing#110](../CodeSnippet/VS_Snippets_Cpp/NVC_ATL_Windowing#110)]  
  
 Note that the first entry in the COM map must be an interface on the object containing the COM map. Thus, you cannot start your COM map entries with `COM_INTERFACE_ENTRY_CHAIN`, which causes the COM map of a different object to be searched at the point where **COM_INTERFACE_ENTRY_CHAIN(**`COtherObject`**)** appears in your object's COM map. If you want to search the COM map of another object first, add an interface entry for **IUnknown** to your COM map, then chain the other object's COM map. For example:  
  
 [!CODE [NVC_ATL_Windowing#111](../CodeSnippet/VS_Snippets_Cpp/NVC_ATL_Windowing#111)]  
  
> [!CAUTION]
>  As of version 3.0, ATL uses the compiler keyword **__uuidof(** `class` **)** to obtain the corresponding IID for a given class. Because of changes in the **COM_INTERFACE_ENTRY** macros effective in version 3.0, now you simply include the header for the interface to use, instead of also linking to a library that defines the matching IIDs for that interface. This change can cause problems if the header was previously generated by an older version of MIDL, or if it was hand-coded and not marked appropriately. If the declaration for the interface in the header has not been marked with an associated **__declspec(** *uuid* **)**, then any attempt to use the `__uuidof` keyword for that interface will fail. You can revert to the older (ATL 2.x) **COM_INTERFACE_ENTRY** macros by defining **_ATL_NO_UUIDOF** in your build settings to work around any problems with this new behavior.  
  
## COM Map Entry Macros  
 The following are the available entry macros:  
  
-   [COM_INTERFACE_ENTRY](../vs140/COM_INTERFACE_ENTRY--ATL-.md)  
  
-   [COM_INTERFACE_ENTRY_IID](../vs140/COM_INTERFACE_ENTRY_IID.md)  
  
-   [COM_INTERFACE_ENTRY2](../vs140/COM_INTERFACE_ENTRY2.md)  
  
-   [COM_INTERFACE_ENTRY2_IID](../vs140/COM_INTERFACE_ENTRY2_IID.md)  
  
-   [COM_INTERFACE_ENTRY_FUNC](../vs140/COM_INTERFACE_ENTRY_FUNC.md)  
  
-   [COM_INTERFACE_ENTRY_FUNC_BLIND](../vs140/COM_INTERFACE_ENTRY_FUNC_BLIND.md)  
  
-   [COM_INTERFACE_ENTRY_TEAR_OFF](../vs140/COM_INTERFACE_ENTRY_TEAR_OFF.md)  
  
-   [COM_INTERFACE_ENTRY_CACHED_TEAR_OFF](../vs140/COM_INTERFACE_ENTRY_CACHED_TEAR_OFF.md)  
  
-   [COM_INTERFACE_ENTRY_AGGREGATE](../vs140/COM_INTERFACE_ENTRY_AGGREGATE.md)  
  
-   [COM_INTERFACE_ENTRY_AGGREGATE_BLIND](../vs140/COM_INTERFACE_ENTRY_AGGREGATE_BLIND.md)  
  
-   [COM_INTERFACE_ENTRY_AUTOAGGREGATE](../vs140/COM_INTERFACE_ENTRY_AUTOAGGREGATE.md)  
  
-   [COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND](../vs140/COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND.md)  
  
-   [COM_INTERFACE_ENTRY_CHAIN](../vs140/COM_INTERFACE_ENTRY_CHAIN.md)  
  
-   [COM_INTERFACE_ENTRY_BREAK](../vs140/COM_INTERFACE_ENTRY_BREAK.md)  
  
-   [COM_INTERFACE_ENTRY_NOINTERFACE](../vs140/COM_INTERFACE_ENTRY_NOINTERFACE.md)  
  
## Requirements  
 **Header:** atlcom.h  
  
## See Also  
 [COM Map Macros](../vs140/COM-Map-Macros.md)   
 [Macros](../vs140/ATL-Macros.md)